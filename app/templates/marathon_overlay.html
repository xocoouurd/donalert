<!DOCTYPE html>
<html lang="mn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marathon Overlay</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: transparent;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Marathon Timer */
        .marathon-timer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: all 0.5s ease;
        }

        .marathon-timer.visible {
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .marathon-timer.hidden {
            opacity: 0;
            transform: translate(-50%, -50%);
        }

        .timer-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 48px;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }


        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Time Notifications */
        .notification-queue {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90vw;
            z-index: 1001;
            pointer-events: none;
            margin-top: 15px;
        }

        .time-notification {
            text-align: center;
            opacity: 0;
            transform: translateY(50px) scale(0.8);
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .time-notification.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .time-notification.hide {
            opacity: 0;
            transform: translateY(-50px) scale(0.8);
        }

        .notification-text {
            font-family: 'Inter', sans-serif;
            font-size: 24px;
            font-weight: 600;
            color: #10b981;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin: 0;
        }

        .notification-text.negative {
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.5);
        }

        /* Marathon Inactive State */
        .marathon-inactive {
            display: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .marathon-timer {
                top: 30px;
                padding: 1.5rem 2rem;
            }
            
            .timer-display {
                font-size: 36px;
            }
            
            .timer-label {
                font-size: 1rem;
            }
            
            .notification-queue {
                bottom: 80px;
                width: 90vw;
            }
            
            .time-notification {
                padding: 1rem 1.5rem;
            }
            
            .notification-text {
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .marathon-timer {
                top: 20px;
                padding: 1rem 1.5rem;
            }
            
            .timer-display {
                font-size: 28px;
            }
            
            .timer-label {
                font-size: 0.9rem;
            }
            
            .notification-text {
                font-size: 18px;
            }
        }


        /* Timer Animation Effects */
        .timer-display.anim-pulse {
            animation: timerPulse 2s ease-in-out infinite;
        }

        .timer-display.anim-bounce {
            animation: timerBounce 2s ease-in-out infinite;
        }

        .timer-display.anim-glow {
            animation: timerGlow 2s ease-in-out infinite;
        }

        .timer-display.anim-shake {
            animation: timerShake 2s ease-in-out infinite;
        }

        .timer-display.anim-zoom {
            animation: timerZoom 2s ease-in-out infinite;
        }

        .timer-display.anim-rotate {
            animation: timerRotate 4s linear infinite;
        }

        /* Animation Keyframes */
        @keyframes timerPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        @keyframes timerBounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-15px);
            }
            60% {
                transform: translateY(-7px);
            }
        }

        @keyframes timerGlow {
            0%, 100% {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }
            50% {
                text-shadow: 0 0 20px currentColor, 0 0 30px currentColor, 2px 2px 4px rgba(0, 0, 0, 0.8);
            }
        }

        @keyframes timerShake {
            0%, 100% {
                transform: translateX(0);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translateX(-3px);
            }
            20%, 40%, 60%, 80% {
                transform: translateX(3px);
            }
        }

        @keyframes timerZoom {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
        }

        @keyframes timerRotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        /* Special effects for milestones */
        .timer-display.milestone {
            animation: milestone 1s ease;
        }

        @keyframes milestone {
            0%, 100% {
                transform: scale(1);
                color: #ffffff;
            }
            25% {
                transform: scale(1.1);
                color: #f59e0b;
            }
            50% {
                transform: scale(1.05);
                color: #10b981;
            }
            75% {
                transform: scale(1.1);
                color: #6366f1;
            }
        }

        /* Low time warning - yellow flash for 4 minutes or less */
        .timer-display.low-time {
            animation: lowTimeWarning 2s ease-in-out infinite;
        }

        /* Critical time warning - red flash at 0:00 */
        .timer-display.critical-time {
            animation: criticalTimeWarning 1.5s ease-in-out infinite;
        }

        @keyframes lowTimeWarning {
            0%, 100% {
                transform: scale(1);
                color: #ffffff;
                opacity: 1;
            }
            25% {
                transform: scale(1.02);
                color: #fbbf24;
                opacity: 0.9;
            }
            50% {
                transform: scale(1.04);
                color: #f59e0b;
                opacity: 0.8;
            }
            75% {
                transform: scale(1.02);
                color: #fbbf24;
                opacity: 0.9;
            }
        }

        @keyframes criticalTimeWarning {
            0%, 100% {
                transform: scale(1);
                color: #ffffff;
                opacity: 1;
            }
            25% {
                transform: scale(1.05);
                color: #ef4444;
                opacity: 0.9;
            }
            50% {
                transform: scale(1.1);
                color: #dc2626;
                opacity: 0.8;
            }
            75% {
                transform: scale(1.05);
                color: #ef4444;
                opacity: 0.9;
            }
        }

        /* Marathon completed state - subtle red flash with zoom */
        .marathon-completed .timer-display {
            animation: marathonCompleted 2s ease-in-out infinite;
        }

        @keyframes marathonCompleted {
            0%, 100% {
                transform: scale(1);
                color: #ffffff;
                opacity: 1;
            }
            25% {
                transform: scale(1.05);
                color: #ff6b6b;
                opacity: 0.9;
            }
            50% {
                transform: scale(1.1);
                color: #ff8a8a;
                opacity: 0.8;
            }
            75% {
                transform: scale(1.05);
                color: #ff6b6b;
                opacity: 0.9;
            }
        }
    </style>
</head>
<body>
    <!-- Marathon Timer -->
    <div class="marathon-timer" id="marathonTimer">
        <div class="timer-display" id="timerDisplay">00:00:00</div>
    </div>

    <!-- Notification Queue -->
    <div class="notification-queue" id="notificationQueue">
        <!-- Time notifications will be dynamically added here -->
    </div>

    <script src="https://cdn.socket.io/4.6.2/socket.io.min.js"></script>
    <script>
        // Universal timer formatting function
        function formatTimerDisplay(timeBreakdown) {
            const days = timeBreakdown.days || 0;
            const hours = timeBreakdown.hours || 0;
            const minutes = timeBreakdown.minutes || 0;
            const seconds = timeBreakdown.seconds || 0;
            
            // If more than 24 hours total, show days
            const totalHours = days * 24 + hours;
            if (totalHours >= 24) {
                return `${days}д ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            } else {
                // Show HH:MM:SS format
                return `${String(totalHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
        }

        // Marathon overlay system
        class MarathonOverlay {
            constructor() {
                this.socket = null;
                this.token = this.getTokenFromUrl();
                this.currentMarathon = null;
                this.countdownInterval = null;
                this.notificationQueue = [];
                this.isProcessingNotifications = false;
                
                this.timerElement = document.getElementById('timerDisplay');
                this.marathonElement = document.getElementById('marathonTimer');
                this.queueElement = document.getElementById('notificationQueue');
                
                this.init();
            }
            
            getTokenFromUrl() {
                return window.location.pathname.split('/').pop();
            }
            
            init() {
                this.initializeSocket();
                this.loadInitialMarathonData();
            }
            
            initializeSocket() {
                // Connect to the correct Socket.IO server based on environment
                const socketUrl = window.location.hostname === '{{ config.SERVER_NAME }}' && window.location.port === '' 
                    ? undefined  // Use default (current domain) for production
                    : '{{ config.SOCKETIO_URL }}';  // Configurable dev server
                
                this.socket = io(socketUrl);
                
                this.socket.on('connect', () => {
                    console.log('Connected to marathon overlay');
                    // Join room if we already have marathon data (for reconnections)
                    if (this.currentMarathon && this.currentMarathon.user_id) {
                        this.joinMarathonRoom();
                    }
                });
                
                this.socket.on('disconnect', () => {
                    console.log('Disconnected from marathon overlay');
                });
                
                this.socket.on('marathon_updated', (data) => {
                    console.log('OVERLAY: Received marathon_updated:', data);
                    this.updateMarathon(data);
                });
                
                this.socket.on('marathon_notification', (data) => {
                    this.addNotification(data);
                });
                
                this.socket.on('request_save_state', (data) => {
                    console.log('OVERLAY: Received save state request');
                    console.log('OVERLAY: Current time before forced save:', this.currentMarathon?.remaining_time);
                    // Save current countdown state immediately
                    this.saveCountdownState();
                    console.log('OVERLAY: Forced save completed');
                });
                
                this.socket.on('connect_error', (error) => {
                    console.error('Socket connection error:', error);
                });
            }
            
            joinMarathonRoom() {
                if (this.token && this.currentMarathon) {
                    this.socket.emit('join', { room: `marathon_overlay_${this.currentMarathon.user_id}` });
                    console.log(`Joined marathon overlay room: marathon_overlay_${this.currentMarathon.user_id}`);
                }
            }
            
            async loadInitialMarathonData() {
                try {
                    console.log('OVERLAY: Loading initial data with token:', this.token);
                    const response = await fetch(`/api/marathon/data?token=${this.token}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        console.log('OVERLAY: Initial marathon data loaded:', result.marathon);
                        this.updateMarathon(result.marathon);
                        this.joinMarathonRoom(); // Join room after we have marathon data
                    } else {
                        console.error('Failed to load marathon data:', result.error);
                        this.hideMarathonTimer();
                    }
                } catch (error) {
                    console.error('Error loading marathon data:', error);
                    this.hideMarathonTimer();
                }
            }
            
            updateMarathon(marathonData) {
                console.log('OVERLAY: updateMarathon called with data:', marathonData);
                console.log('OVERLAY: Current overlay time before update:', this.currentMarathon?.remaining_time);
                
                // If we're currently running a countdown, preserve the client-side state
                const wasRunning = this.currentMarathon && this.countdownInterval;
                const currentSeconds = wasRunning && this.currentMarathon.remaining_time ? this.currentMarathon.remaining_time.seconds : 0;
                const currentMinutes = wasRunning && this.currentMarathon.remaining_time ? this.currentMarathon.remaining_time.total_minutes : 0;
                
                console.log('OVERLAY: Was running countdown:', wasRunning, 'current overlay time:', {minutes: currentMinutes, seconds: currentSeconds});
                
                this.currentMarathon = marathonData;
                console.log('OVERLAY: Updated to server data:', this.currentMarathon.remaining_time);
                
                // Ensure remaining_time exists (use server data, don't override with time_breakdown)
                if (!this.currentMarathon.remaining_time) {
                    this.currentMarathon.remaining_time = {
                        days: 0,
                        hours: 0,
                        minutes: 0,
                        seconds: 0,
                        total_minutes: 0
                    };
                }
                
                // Initialize seconds if not present
                if (!this.currentMarathon.remaining_time.seconds) {
                    this.currentMarathon.remaining_time.seconds = 0;
                }
                
                // If we were running and this is a pause, don't override server data
                // The server should have the exact paused time from the settings page
                if (wasRunning && marathonData.is_paused) {
                    console.log('OVERLAY: Marathon paused, using server time data');
                    // Use server data as-is - it should contain the exact pause time
                }
                
                // Always show the timer overlay - it will display 00:00:00 if no time is set
                // Only hide if the marathon is explicitly disabled or in error state
                
                this.showMarathonTimer();
                this.updateTimerDisplay();
                this.updateTimerFont();
                
                // Start or stop countdown based on marathon state
                if (marathonData.is_running && !marathonData.is_paused) {
                    this.startCountdown();
                } else {
                    // Stop countdown immediately - don't save state when stopping due to pause
                    this.stopCountdown(false); // false = don't save state
                }
            }
            
            updateTimerDisplay() {
                if (!this.currentMarathon) return;
                
                const timeBreakdown = this.currentMarathon.remaining_time;
                const timeString = formatTimerDisplay(timeBreakdown);
                
                // Check for milestone times
                const totalMinutes = timeBreakdown.total_minutes;
                if (totalMinutes > 0 && totalMinutes % 60 === 0) {
                    this.timerElement.classList.add('milestone');
                    setTimeout(() => {
                        this.timerElement.classList.remove('milestone');
                    }, 1000);
                }
                
                // Check for marathon completion - only when BOTH minutes AND seconds are 0
                if (totalMinutes === 0 && timeBreakdown.seconds === 0) {
                    this.marathonElement.classList.add('marathon-completed');
                    this.timerElement.classList.add('critical-time');
                    this.timerElement.classList.remove('low-time');
                    this.stopCountdown();
                    // Auto-reset marathon when it naturally reaches 0
                    this.autoResetMarathon();
                } else {
                    // Timer has time remaining - remove all warning classes
                    this.marathonElement.classList.remove('marathon-completed');
                    this.timerElement.classList.remove('critical-time');
                    
                    // Check for low time warning (4 minutes or less, but not 0:00)
                    if (totalMinutes <= 4 && totalMinutes > 0) {
                        this.timerElement.classList.add('low-time');
                    } else if (totalMinutes === 0 && timeBreakdown.seconds > 0) {
                        // 0 minutes but has seconds (0:XX) - also low time warning
                        this.timerElement.classList.add('low-time');
                    } else {
                        this.timerElement.classList.remove('low-time');
                    }
                }
                
                this.timerElement.textContent = timeString;
            }
            
            
            updateTimerFont() {
                if (!this.currentMarathon) return;
                
                this.timerElement.style.fontSize = this.currentMarathon.timer_font_size + 'px';
                this.timerElement.style.fontWeight = this.currentMarathon.timer_font_weight;
                this.timerElement.style.color = this.currentMarathon.timer_font_color;
                
                // Apply animation
                this.updateTimerAnimation();
                
                // Update notification queue position based on timer height
                this.updateNotificationPosition();
            }
            
            updateNotificationPosition() {
                // Calculate the position for notification queue based on timer height
                const timerHeight = this.timerElement.offsetHeight;
                const halfTimerHeight = timerHeight / 2;
                this.queueElement.style.marginTop = (halfTimerHeight + 15) + 'px';
            }
            
            updateTimerAnimation() {
                if (!this.currentMarathon) return;
                
                // Remove all animation classes
                this.timerElement.classList.remove('anim-pulse', 'anim-bounce', 'anim-glow', 'anim-shake', 'anim-zoom', 'anim-rotate');
                
                // Add the selected animation class
                if (this.currentMarathon.timer_animation && this.currentMarathon.timer_animation !== 'none') {
                    this.timerElement.classList.add('anim-' + this.currentMarathon.timer_animation);
                }
            }
            
            showMarathonTimer() {
                this.marathonElement.classList.remove('hidden');
                this.marathonElement.classList.add('visible');
            }
            
            hideMarathonTimer() {
                this.marathonElement.classList.remove('visible');
                this.marathonElement.classList.add('hidden');
                this.stopCountdown();
            }
            
            startCountdown() {
                this.stopCountdown(); // Clear any existing interval
                
                // Initialize seconds if not present
                if (!this.currentMarathon.remaining_time.seconds) {
                    this.currentMarathon.remaining_time.seconds = 0;
                }
                
                let saveCounter = 0; // Save state every 10 seconds
                
                this.countdownInterval = setInterval(() => {
                    if (this.currentMarathon && (this.currentMarathon.remaining_time.total_minutes > 0 || this.currentMarathon.remaining_time.seconds > 0)) {
                        // Decrease by 1 second
                        if (this.currentMarathon.remaining_time.seconds > 0) {
                            this.currentMarathon.remaining_time.seconds--;
                        } else {
                            // Only move to next minute if we have minutes left
                            if (this.currentMarathon.remaining_time.total_minutes > 0) {
                                this.currentMarathon.remaining_time.seconds = 59;
                                this.currentMarathon.remaining_time.total_minutes--;
                                
                                // Recalculate breakdown to ensure consistency
                                const totalMinutes = this.currentMarathon.remaining_time.total_minutes;
                                this.currentMarathon.remaining_time.days = Math.floor(totalMinutes / (24 * 60));
                                const remainingAfterDays = totalMinutes % (24 * 60);
                                this.currentMarathon.remaining_time.hours = Math.floor(remainingAfterDays / 60);
                                this.currentMarathon.remaining_time.minutes = remainingAfterDays % 60;
                            } else {
                                // We're at 0 minutes and 0 seconds - auto-reset marathon
                                this.currentMarathon.remaining_time.seconds = 0;
                                this.stopCountdown();
                                this.autoResetMarathon();
                                return;
                            }
                        }
                        
                        this.updateTimerDisplay();
                        
                        // Save state every 10 seconds or when minutes change
                        saveCounter++;
                        if (saveCounter >= 10 || this.currentMarathon.remaining_time.seconds === 59) {
                            this.saveCountdownState();
                            saveCounter = 0;
                        }
                    } else {
                        // No time left - stop countdown
                        this.stopCountdown();
                        this.saveCountdownState();
                    }
                }, 1000); // Update every second
            }
            
            stopCountdown(saveState = true) {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                    
                    // Only save state if requested (default true for normal stops)
                    if (saveState) {
                        this.saveCountdownState();
                    }
                }
            }
            
            // Save countdown state to database
            async saveCountdownState() {
                try {
                    console.log('OVERLAY: Saving countdown state - minutes:', this.currentMarathon.remaining_time.total_minutes, 'seconds:', this.currentMarathon.remaining_time.seconds);
                    
                    const response = await fetch('/api/marathon/update-countdown', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            token: this.token,
                            minutes: this.currentMarathon.remaining_time.total_minutes,
                            seconds: this.currentMarathon.remaining_time.seconds
                        })
                    });
                    
                    if (!response.ok) {
                        console.warn('OVERLAY: Failed to save countdown state - HTTP', response.status);
                    } else {
                        console.log('OVERLAY: Successfully saved countdown state to database');
                    }
                } catch (error) {
                    console.warn('OVERLAY: Error saving countdown state:', error);
                }
            }
            
            // Auto-reset marathon when timer reaches 0
            async autoResetMarathon() {
                try {
                    console.log('OVERLAY: Auto-resetting marathon at 0:00');
                    
                    const response = await fetch('/api/marathon/auto-reset', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            token: this.token
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            console.log('OVERLAY: Marathon auto-reset successful');
                            // The backend will send a marathon_updated event via WebSocket
                        }
                    } else {
                        console.warn('Failed to auto-reset marathon');
                    }
                } catch (error) {
                    console.warn('Error auto-resetting marathon:', error);
                }
            }
            
            addNotification(notificationData) {
                this.notificationQueue.push(notificationData);
                if (!this.isProcessingNotifications) {
                    this.processNotificationQueue();
                }
            }
            
            async processNotificationQueue() {
                if (this.notificationQueue.length === 0) {
                    this.isProcessingNotifications = false;
                    return;
                }
                
                this.isProcessingNotifications = true;
                const notification = this.notificationQueue.shift();
                
                await this.showNotification(notification);
                
                // Process next notification after a delay
                setTimeout(() => {
                    this.processNotificationQueue();
                }, 500);
            }
            
            showNotification(notificationData) {
                return new Promise((resolve) => {
                    const notificationElement = document.createElement('div');
                    notificationElement.className = 'time-notification';
                    
                    const textElement = document.createElement('div');
                    textElement.className = 'notification-text';
                    textElement.textContent = notificationData.text;
                    
                    // Apply font settings
                    textElement.style.fontSize = notificationData.font_size + 'px';
                    textElement.style.fontWeight = notificationData.font_weight;
                    textElement.style.color = notificationData.font_color;
                    
                    // Add negative class for time removal
                    if (notificationData.minutes < 0) {
                        textElement.classList.add('negative');
                        notificationElement.style.borderColor = 'rgba(239, 68, 68, 0.5)';
                    }
                    
                    notificationElement.appendChild(textElement);
                    this.queueElement.appendChild(notificationElement);
                    
                    // Show notification with animation
                    setTimeout(() => {
                        notificationElement.classList.add('show');
                    }, 100);
                    
                    // Hide notification after 4 seconds
                    setTimeout(() => {
                        notificationElement.classList.add('hide');
                        
                        // Remove from DOM after animation
                        setTimeout(() => {
                            if (notificationElement.parentNode) {
                                notificationElement.parentNode.removeChild(notificationElement);
                            }
                            resolve();
                        }, 500);
                    }, 4000);
                });
            }
        }
        
        // Initialize marathon overlay when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new MarathonOverlay();
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // Refresh marathon data when page becomes visible
                setTimeout(() => {
                    if (window.marathonOverlay) {
                        window.marathonOverlay.loadInitialMarathonData();
                    }
                }, 1000);
            }
        });
    </script>
</body>
</html>