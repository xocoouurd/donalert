<!DOCTYPE html>
<html lang="mn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DonAlert Overlay</title>
    
    <!-- Match the same fonts and base styling as the main site -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/overlay.css') }}">
</head>
<body>
    <!-- Main alert container -->
    <div id="alertContainer"></div>

    <!-- Audio element for sound effects -->
    <audio id="alertSound" preload="auto"></audio>
    
    <!-- Audio element for TTS -->
    <audio id="ttsAudio" preload="auto"></audio>

    <script src="https://cdn.socket.io/4.6.2/socket.io.min.js"></script>
    <script>
        // Configuration from server
        const userId = {{ user.id }};
        const settings = {{ settings.to_dict() | tojson }};
        {% if has_advanced_tier %}
        const alertConfigurations = {{ alert_configurations | tojson }};
        const hasAdvancedTier = true;
        {% else %}
        const alertConfigurations = null;
        const hasAdvancedTier = false;
        {% endif %}
        
        
        // Get configuration for alert based on tab number or amount
        function getConfigForAlert(alertData) {
            
            if (!hasAdvancedTier || !alertConfigurations) {
                return settings;
            }
            
            // If alert has tab_number, use that specific configuration
            if (alertData.tab_number) {
                const config = alertConfigurations.find(c => c.tab_number === alertData.tab_number);
                if (config) {
                    return config;
                } else {
                }
            }
            
            // If alert has config_id, use that specific configuration
            if (alertData.config_id) {
                const config = alertConfigurations.find(c => c.id === alertData.config_id);
                if (config) {
                    return config;
                } else {
                }
            }
            
            // Find configuration based on amount (get highest minimum_amount that's <= donation amount)
            if (alertData.amount) {
                const eligibleConfigs = alertConfigurations.filter(c => c.minimum_amount <= alertData.amount);
                if (eligibleConfigs.length > 0) {
                    // Sort by minimum_amount descending and take the first (highest threshold)
                    eligibleConfigs.sort((a, b) => b.minimum_amount - a.minimum_amount);
                    return eligibleConfigs[0];
                }
            }
            
            // Fallback to first configuration
            return alertConfigurations[0] || settings;
        }
        
        // Alert queue management
        let alertQueue = [];
        let isShowingAlert = false;
        
        // Sound effects queue management
        let soundQueue = [];
        let isPlayingSoundEffect = false;
        
        // Initialize WebSocket connection (only if socket.io is available)
        let socket = null;
        
        if (typeof io !== 'undefined') {
            // Connect to the correct Socket.IO server based on environment
            const socketUrl = window.location.hostname === '{{ config.SERVER_NAME }}' && window.location.port === '' 
                ? undefined  // Use default (current domain) for production
                : '{{ config.SOCKETIO_URL }}';  // Configurable dev server
            
            
            socket = io(socketUrl, {
                transports: ['websocket', 'polling'],
                upgrade: true,
                rememberUpgrade: true
            });
            
            // Join user's room for personalized alerts
            const roomName = `user_${userId}`;
            socket.emit('join', {room: roomName});
            
            // Listen for donation alerts
            socket.on('donation_alert', function(data) {
                queueAlert(data);
            });
            
            // Listen for sound effect alerts
            socket.on('sound_effect_alert', function(data) {
                
                // Queue sound effect for playback
                queueSoundEffect(data);
            });
            
            // Listen for test alerts
            socket.on('test_alert', function(data) {
                
                // Use the same queueing system as real donations
                queueAlert(data);
            });

            // Listen for settings updates
            socket.on('settings_updated', function(data) {
                
                // Handle advanced tier configuration updates (has tab_number and config)
                if (data.tab_number && data.config && hasAdvancedTier && alertConfigurations) {
                    
                    // Find and update the specific tab configuration
                    const configIndex = alertConfigurations.findIndex(c => c.tab_number === data.tab_number);
                    if (configIndex !== -1) {
                        const oldConfig = alertConfigurations[configIndex];
                        
                        // Check if sound changed for this tab
                        if (data.config.sound_url !== oldConfig.sound_url) {
                            // Preload the new sound
                            preloadSound(data.config.sound_url);
                        }
                        
                        // Check if volume changed
                        if (data.config.sound_volume !== oldConfig.sound_volume) {
                        }
                        
                        // Update the configuration
                        alertConfigurations[configIndex] = data.config;
                    } else {
                        alertConfigurations.push(data.config);
                    }
                }
                // Handle basic tier settings updates (legacy format)
                else if (!data.tab_number && !data.config) {
                    
                    // Check if sound changed
                    if (data.sound_url !== settings.sound_url) {
                        preloadSound(data.sound_url);
                    }
                    
                    // Update all settings
                    Object.assign(settings, data);
                }
                else {
                }
            });
            
            // Listen for room join acknowledgments
            socket.on('room_joined', function(data) {
            });
            
            // Connection status logging
            socket.on('connect', function() {
                
                // Re-join room after connection
                const roomName = `user_${userId}`;
                socket.emit('join', {room: roomName});
                
                // Preload initial sound after connection
                preloadSound(settings.sound_url);
            });
            
            socket.on('disconnect', function() {
            });
            
            socket.on('error', function(error) {
            });
            
            // Auto-reconnection
            socket.on('connect_error', function(error) {
            });
            
        } else {
        }

        // Preload initial sound (fallback if no socket connection)
        setTimeout(() => {
            if (settings.sound_url) {
                preloadSound(settings.sound_url);
            }
        }, 1000);
        
        function queueAlert(alertData) {
            // Check minimum amount
            if (alertData.amount < settings.minimum_amount) {
                return;
            }
            
            // Add to queue
            alertQueue.push(alertData);
            
            // Process queue if not currently showing alert
            if (!isShowingAlert) {
                processQueue();
            }
        }
        
        function processQueue() {
            if (alertQueue.length === 0) {
                isShowingAlert = false;
                return;
            }
            
            isShowingAlert = true;
            const alertData = alertQueue.shift();
            
            showAlert(alertData);
        }
        
        // Sound effects queue management
        function queueSoundEffect(soundData) {
            
            // Add to sound queue
            soundQueue.push(soundData);
            
            // Process sound queue if not currently playing
            if (!isPlayingSoundEffect) {
                processSoundQueue();
            }
        }
        
        function processSoundQueue() {
            if (soundQueue.length === 0) {
                isPlayingSoundEffect = false;
                return;
            }
            
            isPlayingSoundEffect = true;
            const soundData = soundQueue.shift();
            
            playSoundEffect(soundData);
        }
        
        function playSoundEffect(soundData) {
            
            try {
                // Create audio element for sound effect
                const audio = new Audio(soundData.file_url);
                
                // Set volume based on user's preference (convert percentage to decimal)
                const volumePercent = soundData.volume_level || 70;
                audio.volume = Math.min(1.0, Math.max(0.0, volumePercent / 100));
                
                // Play the sound
                audio.play().then(() => {
                }).catch(error => {
                });
                
                // Schedule next sound effect after duration + 1 second gap
                const duration = (soundData.duration_seconds * 1000) + 1000;
                
                setTimeout(() => {
                    processSoundQueue();
                }, duration);
                
            } catch (error) {
                // Continue with queue on error
                setTimeout(() => processSoundQueue(), 1000);
            }
        }
        
        
        function showAlert(alertData) {
            
            // Get the correct configuration for this alert
            const alertConfig = getConfigForAlert(alertData);
            
            // Set showing flag
            isShowingAlert = true;
            
            const container = document.getElementById('alertContainer');
            
            // Play sound if configured
            if (alertConfig.sound_url && alertData.amount >= alertConfig.minimum_amount) {
                playAlertSound(alertConfig);
            }
            
            // Play TTS if backend provided audio URL
            if (alertData.tts_audio_url) {
                playTTSFromURL(alertData.tts_audio_url, alertConfig);
            }
            
            // Create alert HTML using the correct configuration
            const alertHTML = createAlertHTML(alertData, alertConfig);
            container.innerHTML = alertHTML;
            
            // Set CSS custom property for animation speed
            document.documentElement.style.setProperty('--animation-speed', `${alertConfig.animation_speed}ms`);
            
            // Apply entrance animation
            const alertElement = container.querySelector('.donation-alert');
            alertElement.classList.add(alertConfig.transition_type);
            
            // RELIABLE TIMING SEQUENCE: entrance → visible → exit
            // Phase 1: Entrance animation (animation_speed ms)
            setTimeout(() => {
                
                // Phase 2: Visible time (visible_time ms)
                setTimeout(() => {
                    hideAlert(alertElement, alertConfig);
                }, alertConfig.visible_time);
                
            }, alertConfig.animation_speed);
        }
        
        function createAlertHTML(alertData, alertConfig = settings) {
            const donatorName = alertData.donator_name || 'Анонимус';
            const amount = alertData.amount;
            const message = alertData.message || '';
            const donatorAvatar = alertData.donator_avatar;
            const hasAvatar = alertData.has_avatar;
            
            // Process text template
            let processedText = alertConfig.text_template
                .replace(/{name}/g, donatorName)
                .replace(/{amount}/g, amount.toLocaleString());
            
            // Apply text formatting
            processedText = processedText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\[(.*?)\]/g, `<span style="color: ${alertConfig.template_accent_color}">$1</span>`);
            
            // Determine layout classes
            const isVertical = alertConfig.image_position === 'top' || alertConfig.image_position === 'bottom';
            const isReverse = alertConfig.image_position === 'right' || alertConfig.image_position === 'bottom';
            
            let contentClass = 'alert-content';
            if (isVertical) {
                contentClass += isReverse ? ' vertical-reverse' : ' vertical';
            } else {
                contentClass += isReverse ? ' horizontal-reverse' : '';
            }
            
            return `
                <div class="donation-alert">
                    ${alertData.donator_name ? `
                        <div class="donator-profile">
                            ${hasAvatar ? `
                                <img src="${donatorAvatar}" alt="${donatorName}" class="donator-avatar" 
                                     style="width: ${alertConfig.donator_image_size}px; height: ${alertConfig.donator_image_size}px;">
                            ` : ''}
                            <div class="donator-name" style="
                                font-size: ${alertConfig.donator_name_size}px;
                                font-weight: ${alertConfig.donator_name_weight};
                                color: ${alertConfig.donator_color};
                                text-align: ${alertConfig.donator_alignment};
                            ">${donatorName}</div>
                        </div>
                    ` : ''}
                    
                    <div class="${contentClass}">
                        <div class="alert-image">
                            <img src="${alertConfig.gif_url}" alt="Donation GIF" style="
                                width: ${Math.round(120 * alertConfig.image_size / 100)}px;
                                height: ${Math.round(120 * alertConfig.image_size / 100)}px;
                                object-fit: cover;
                            ">
                        </div>
                        
                        <div class="alert-text" style="
                            font-size: ${alertConfig.template_size}px;
                            font-weight: ${alertConfig.template_weight};
                            color: ${alertConfig.template_base_color};
                            text-align: ${alertConfig.template_alignment};
                        ">${processedText}</div>
                    </div>
                    
                    ${message ? `
                        <div class="alert-message" style="
                            font-size: ${alertConfig.message_size}px;
                            font-weight: ${alertConfig.message_weight};
                            color: ${alertConfig.message_color};
                            text-align: ${alertConfig.message_alignment};
                            font-style: ${alertConfig.message_style};
                        ">"${message}"</div>
                    ` : ''}
                </div>
            `;
        }
        
        function hideAlert(alertElement, alertConfig = settings) {
            
            // Get the opposite exit animation based on entrance animation
            const exitAnimation = getExitAnimation(alertConfig.transition_type);
            
            // Remove entrance animation class and add exit animation class
            alertElement.classList.remove(alertConfig.transition_type);
            alertElement.classList.add(exitAnimation);
            
            // Phase 3: Exit animation (animation_speed ms) - then immediately process next
            setTimeout(() => {
                
                document.getElementById('alertContainer').innerHTML = '';
                
                // Reset showing flag
                isShowingAlert = false;
                
                // IMMEDIATELY process next alert in queue (no extra delay)
                processQueue();
            }, alertConfig.animation_speed);
        }
        
        function getExitAnimation(entranceAnimation) {
            // Map entrance animations to their opposite exit animations
            const exitMap = {
                'fade-in': 'fade-out',
                'slide-up': 'slide-down-exit',
                'slide-down': 'slide-up-exit', 
                'slide-left': 'slide-right-exit',
                'slide-right': 'slide-left-exit',
                'zoom-in': 'zoom-out'
            };
            
            return exitMap[entranceAnimation] || 'fade-out';
        }
        
        function preloadSound(soundUrl) {
            if (soundUrl) {
                const audio = document.getElementById('alertSound');
                audio.src = soundUrl;
                audio.load(); // Preload the audio file
            }
        }

        function playAlertSound(alertConfig = settings) {
            const audio = document.getElementById('alertSound');
            
            // Set the correct sound URL from the tab-specific config
            audio.src = alertConfig.sound_url;
            audio.currentTime = 0; // Reset to start
            
            // Use tab-specific volume setting
            audio.volume = alertConfig.sound_volume / 100;
            
            
            audio.play().catch(e => {
            });
        }
        
        function playTTSFromURL(audioUrl, alertConfig = settings) {
            
            const ttsAudio = document.getElementById('ttsAudio');
            ttsAudio.src = audioUrl;
            ttsAudio.volume = 1.0; // TTS always plays at 100% volume
            
            
            // Play TTS after a short delay to avoid overlapping with alert sound
            setTimeout(() => {
                ttsAudio.play().catch(e => {
                });
            }, 1000);
            
            ttsAudio.onended = () => {
                // Clean up the TTS file after playback
                if (audioUrl && audioUrl.includes('/static/uploads/tts/')) {
                    fetch('/api/tts/cleanup', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ file_url: audioUrl })
                    }).catch(e => {
                        // Silent cleanup failure
                    });
                }
            };
        }
        
        // Legacy function - keeping for backward compatibility
        function playTTSMessage(message) {
        }
        
        // Test function for manual testing
        window.testAlert = function() {
            const testData = {
                donator_name: 'Тест хэрэглэгч',
                amount: 5000,
                message: 'Энэ бол туршилтын мессеж!',
                donator_avatar: '/static/assets/default/avatar.png'
            };
            
            showAlert(testData);
        };
        
        // Auto-test disabled - overlay waits for real alerts
        // To manually test, open browser console and run: window.testAlert()
        
    </script>
</body>
</html>