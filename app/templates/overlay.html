<!DOCTYPE html>
<html lang="mn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DonAlert Overlay</title>
    
    <!-- Match the same fonts and base styling as the main site -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/overlay.css') }}">
</head>
<body>
    <!-- Main alert container -->
    <div id="alertContainer"></div>
    
    <!-- Alert queue for upcoming donations -->
    <div id="alertQueue" class="alert-queue"></div>

    <!-- Audio element for sound effects -->
    <audio id="alertSound" preload="auto"></audio>
    
    <!-- Audio element for TTS -->
    <audio id="ttsAudio" preload="auto"></audio>

    <script src="https://cdn.socket.io/4.6.2/socket.io.min.js"></script>
    <script>
        // Configuration from server
        const userId = {{ user.id }};
        const settings = {{ settings.to_dict() | tojson }};
        {% if has_advanced_tier %}
        const alertConfigurations = {{ alert_configurations | map('to_dict') | list | tojson }};
        const hasAdvancedTier = true;
        {% else %}
        const alertConfigurations = null;
        const hasAdvancedTier = false;
        {% endif %}
        
        console.log('=== OVERLAY PAGE INITIALIZATION ===');
        console.log('User ID:', userId);
        console.log('Settings loaded:', !!settings);
        console.log('Advanced tier:', hasAdvancedTier);
        console.log('Configurations:', alertConfigurations?.length || 0);
        console.log('typeof io:', typeof io);
        
        // Get configuration for alert based on tab number or amount
        function getConfigForAlert(alertData) {
            if (!hasAdvancedTier || !alertConfigurations) {
                return settings;
            }
            
            // If alert has tab_number, use that specific configuration
            if (alertData.tab_number) {
                const config = alertConfigurations.find(c => c.tab_number === alertData.tab_number);
                if (config) return config;
            }
            
            // If alert has config_id, use that specific configuration
            if (alertData.config_id) {
                const config = alertConfigurations.find(c => c.id === alertData.config_id);
                if (config) return config;
            }
            
            // Find configuration based on amount (get highest minimum_amount that's <= donation amount)
            if (alertData.amount) {
                const eligibleConfigs = alertConfigurations.filter(c => c.minimum_amount <= alertData.amount);
                if (eligibleConfigs.length > 0) {
                    // Sort by minimum_amount descending and take the first (highest threshold)
                    eligibleConfigs.sort((a, b) => b.minimum_amount - a.minimum_amount);
                    return eligibleConfigs[0];
                }
            }
            
            // Fallback to first configuration
            return alertConfigurations[0] || settings;
        }
        
        // Alert queue management
        let alertQueue = [];
        let isShowingAlert = false;
        
        // Initialize WebSocket connection (only if socket.io is available)
        let socket = null;
        
        if (typeof io !== 'undefined') {
            console.log('‚úÖ Socket.IO library available');
            // Connect to the correct Socket.IO server based on environment
            const socketUrl = window.location.hostname === '{{ config.SERVER_NAME }}' && window.location.port === '' 
                ? undefined  // Use default (current domain) for production
                : '{{ config.SOCKETIO_URL }}';  // Configurable dev server
            
            console.log('Socket URL:', socketUrl || 'default (current domain)');
            console.log('Current hostname:', window.location.hostname);
            console.log('Current port:', window.location.port);
            console.log('Expected server name:', '{{ config.SERVER_NAME }}');
            
            socket = io(socketUrl, {
                transports: ['websocket', 'polling'],
                upgrade: true,
                rememberUpgrade: true
            });
            
            // Join user's room for personalized alerts
            const roomName = `user_${userId}`;
            console.log('üè† Attempting to join room:', roomName);
            socket.emit('join', {room: roomName});
            
            // Listen for donation alerts
            socket.on('donation_alert', function(data) {
                queueAlert(data);
            });
            
            // Listen for test alerts
            socket.on('test_alert', function(data) {
                console.log('üß™ OVERLAY: Test alert received!', data);
                
                // If already showing an alert, ignore additional test alerts
                if (isShowingAlert) {
                    console.log('‚ö†Ô∏è OVERLAY: Ignored test alert - already showing alert');
                    return;
                }
                
                console.log('‚úÖ OVERLAY: Processing test alert...');
                showAlert(data);
            });

            // Listen for settings updates
            socket.on('settings_updated', function(newSettings) {
                
                // Check if sound changed
                if (newSettings.sound_url !== settings.sound_url) {
                    preloadSound(newSettings.sound_url);
                }
                
                // Update all settings
                Object.assign(settings, newSettings);
            });
            
            // Listen for room join acknowledgments
            socket.on('room_joined', function(data) {
                console.log('üè† OVERLAY: Successfully joined room:', data);
            });
            
            // Connection status logging
            socket.on('connect', function() {
                console.log('‚úÖ OVERLAY: Socket connected!', socket.id);
                
                // Re-join room after connection
                const roomName = `user_${userId}`;
                console.log('üè† OVERLAY: Re-joining room after connection:', roomName);
                socket.emit('join', {room: roomName});
                
                // Preload initial sound after connection
                preloadSound(settings.sound_url);
            });
            
            socket.on('disconnect', function() {
                console.log('‚ùå OVERLAY: Socket disconnected');
            });
            
            socket.on('error', function(error) {
                console.log('‚ùå OVERLAY: Socket error:', error);
            });
            
            // Auto-reconnection
            socket.on('connect_error', function(error) {
                console.log('‚ùå OVERLAY: Socket connection error:', error);
            });
            
            console.log('‚úÖ OVERLAY: Socket setup complete, waiting for connection...');
        } else {
            console.log('‚ùå OVERLAY: Socket.IO library not available!');
        }

        // Preload initial sound (fallback if no socket connection)
        setTimeout(() => {
            if (settings.sound_url) {
                preloadSound(settings.sound_url);
            }
        }, 1000);
        
        function queueAlert(alertData) {
            // Check minimum amount
            if (alertData.amount < settings.minimum_amount) {
                return;
            }
            
            // Add to queue
            alertQueue.push(alertData);
            updateQueueDisplay();
            
            // Process queue if not currently showing alert
            if (!isShowingAlert) {
                processQueue();
            }
        }
        
        function processQueue() {
            if (alertQueue.length === 0) {
                isShowingAlert = false;
                return;
            }
            
            isShowingAlert = true;
            const alertData = alertQueue.shift();
            updateQueueDisplay();
            
            showAlert(alertData);
        }
        
        function updateQueueDisplay() {
            const queueContainer = document.getElementById('alertQueue');
            queueContainer.innerHTML = '';
            
            // Show next few alerts in queue
            alertQueue.slice(0, 3).forEach((alert, index) => {
                const queueItem = document.createElement('div');
                queueItem.className = 'queue-item';
                queueItem.innerHTML = `
                    <div style="font-weight: bold;">${alert.donator_name || '–ê–Ω–æ–Ω–∏–º—É—Å'}</div>
                    <div>${alert.amount.toLocaleString()}‚ÇÆ</div>
                `;
                queueContainer.appendChild(queueItem);
            });
        }
        
        function showAlert(alertData) {
            console.log('üéØ OVERLAY: showAlert() called with data:', alertData);
            console.log('Current isShowingAlert state:', isShowingAlert);
            
            // Get the correct configuration for this alert
            const alertConfig = getConfigForAlert(alertData);
            console.log('Using configuration for tab:', alertConfig.tab_number || 1);
            
            // Set showing flag
            isShowingAlert = true;
            
            const container = document.getElementById('alertContainer');
            
            // Play sound if configured
            if (alertConfig.sound_url && alertData.amount >= alertConfig.tts_minimum_amount) {
                playAlertSound(alertConfig);
            }
            
            // Play TTS if backend provided audio URL
            if (alertData.tts_audio_url) {
                playTTSFromURL(alertData.tts_audio_url);
            } else {
            }
            
            // Create alert HTML using the correct configuration
            const alertHTML = createAlertHTML(alertData, alertConfig);
            container.innerHTML = alertHTML;
            
            // Set CSS custom property for animation speed
            document.documentElement.style.setProperty('--animation-speed', `${alertConfig.animation_speed}ms`);
            
            // Apply entrance animation
            const alertElement = container.querySelector('.donation-alert');
            alertElement.classList.add(alertConfig.transition_type);
            
            // Wait for entrance animation to complete, then show for visible duration
            setTimeout(() => {
                
                // Wait for the full visibility duration, then start exit animation
                setTimeout(() => {
                    hideAlert(alertElement, alertConfig);
                }, alertConfig.visible_time);
                
            }, alertConfig.animation_speed);
        }
        
        function createAlertHTML(alertData, alertConfig = settings) {
            const donatorName = alertData.donator_name || '–ê–Ω–æ–Ω–∏–º—É—Å';
            const amount = alertData.amount;
            const message = alertData.message || '';
            const donatorAvatar = alertData.donator_avatar;
            const hasAvatar = alertData.has_avatar;
            
            // Process text template
            let processedText = alertConfig.text_template
                .replace(/{name}/g, donatorName)
                .replace(/{amount}/g, amount.toLocaleString());
            
            // Apply text formatting
            processedText = processedText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\[(.*?)\]/g, `<span style="color: ${alertConfig.template_accent_color}">$1</span>`);
            
            // Determine layout classes
            const isVertical = alertConfig.image_position === 'top' || alertConfig.image_position === 'bottom';
            const isReverse = alertConfig.image_position === 'right' || alertConfig.image_position === 'bottom';
            
            let contentClass = 'alert-content';
            if (isVertical) {
                contentClass += isReverse ? ' vertical-reverse' : ' vertical';
            } else {
                contentClass += isReverse ? ' horizontal-reverse' : '';
            }
            
            return `
                <div class="donation-alert">
                    ${alertData.donator_name ? `
                        <div class="donator-profile">
                            ${hasAvatar ? `
                                <img src="${donatorAvatar}" alt="${donatorName}" class="donator-avatar" 
                                     style="width: ${alertConfig.donator_image_size}px; height: ${alertConfig.donator_image_size}px;">
                            ` : ''}
                            <div class="donator-name" style="
                                font-size: ${alertConfig.donator_name_size}px;
                                font-weight: ${alertConfig.donator_name_weight};
                                color: ${alertConfig.donator_color};
                                text-align: ${alertConfig.donator_alignment};
                            ">${donatorName}</div>
                        </div>
                    ` : ''}
                    
                    <div class="${contentClass}">
                        <div class="alert-image">
                            <img src="${alertConfig.gif_url}" alt="Donation GIF" style="
                                width: ${Math.round(120 * alertConfig.image_size / 100)}px;
                                height: ${Math.round(120 * alertConfig.image_size / 100)}px;
                                object-fit: cover;
                            ">
                        </div>
                        
                        <div class="alert-text" style="
                            font-size: ${alertConfig.template_size}px;
                            font-weight: ${alertConfig.template_weight};
                            color: ${alertConfig.template_base_color};
                            text-align: ${alertConfig.template_alignment};
                        ">${processedText}</div>
                    </div>
                    
                    ${message ? `
                        <div class="alert-message" style="
                            font-size: ${alertConfig.message_size}px;
                            font-weight: ${alertConfig.message_weight};
                            color: ${alertConfig.message_color};
                            text-align: ${alertConfig.message_alignment};
                            font-style: ${alertConfig.message_style};
                        ">"${message}"</div>
                    ` : ''}
                </div>
            `;
        }
        
        function hideAlert(alertElement, alertConfig = settings) {
            
            // Get the opposite exit animation based on entrance animation
            const exitAnimation = getExitAnimation(alertConfig.transition_type);
            
            // Remove entrance animation class and add exit animation class
            alertElement.classList.remove(alertConfig.transition_type);
            alertElement.classList.add(exitAnimation);
            
            // Wait for exit animation to complete
            setTimeout(() => {
                document.getElementById('alertContainer').innerHTML = '';
                
                // Reset showing flag
                isShowingAlert = false;
                
                // Process next alert in queue
                setTimeout(() => {
                    processQueue();
                }, 500);
            }, alertConfig.animation_speed);
        }
        
        function getExitAnimation(entranceAnimation) {
            // Map entrance animations to their opposite exit animations
            const exitMap = {
                'fade-in': 'fade-out',
                'slide-up': 'slide-down-exit',
                'slide-down': 'slide-up-exit', 
                'slide-left': 'slide-right-exit',
                'slide-right': 'slide-left-exit',
                'zoom-in': 'zoom-out'
            };
            
            return exitMap[entranceAnimation] || 'fade-out';
        }
        
        function preloadSound(soundUrl) {
            if (soundUrl) {
                const audio = document.getElementById('alertSound');
                audio.src = soundUrl;
                audio.load(); // Preload the audio file
            }
        }

        function playAlertSound() {
            const audio = document.getElementById('alertSound');
            audio.currentTime = 0; // Reset to start
            audio.volume = settings.sound_volume / 100;
            audio.play().catch(e => {
                // Silent audio play failure
            });
        }
        
        function playTTSFromURL(audioUrl) {
            
            const ttsAudio = document.getElementById('ttsAudio');
            ttsAudio.src = audioUrl;
            ttsAudio.volume = settings.sound_volume / 100;
            
            // Play TTS after a short delay to avoid overlapping with alert sound
            setTimeout(() => {
                ttsAudio.play().catch(e => {
                });
            }, 1000);
            
            ttsAudio.onended = () => {
                // Clean up the TTS file after playback
                if (audioUrl && audioUrl.includes('/static/uploads/tts/')) {
                    fetch('/api/tts/cleanup', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ file_url: audioUrl })
                    }).catch(e => {
                        // Silent cleanup failure
                    });
                }
            };
        }
        
        // Legacy function - keeping for backward compatibility
        function playTTSMessage(message) {
        }
        
        // Test function for manual testing
        window.testAlert = function() {
            const testData = {
                donator_name: '–¢–µ—Å—Ç —Ö—ç—Ä—ç–≥–ª—ç–≥—á',
                amount: 5000,
                message: '–≠–Ω—ç –±–æ–ª —Ç—É—Ä—à–∏–ª—Ç—ã–Ω –º–µ—Å—Å–µ–∂!',
                donator_avatar: '/static/assets/default/avatar.png'
            };
            
            showAlert(testData);
        };
        
        // Auto-test disabled - overlay waits for real alerts
        // To manually test, open browser console and run: window.testAlert()
        
    </script>
</body>
</html>